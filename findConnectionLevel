#Abhi

import numpy as np


def checkConnection(x,v,arr):
  for j in range(v):
    current=[]
    n=0
    if arr[x][j]==1:
      current+=[j] 
      n+=1
    return check(current[0],v,arr)
    
def findConnectionLevel(v, arr, x, y):
  
  for j in range(v):
    if arr[x][j] == 0:
      return 0

  for i in range(v):
    if arr[i][y] == 0:
      return 0

  if arr[x][y] == 1:
      return 1
  
vertices = int(input())
Amat = []
for i in range(vertices):
  row = [int(item) for item in input().split(" ")]
  Amat.append(row)
personX = int(input())
personY = int(input())
print(findConnectionLevel(vertices, Amat, personX, personY))


#Akshay

# vec_array = [

#     # 0
#     [1,1,0,0,1,0,1],
#     # 1
#     [1,1,0,0,1,0,1],
#     # 2
#     [1,1,1,0,1,0,1],
#     # 3
#     [1,1,0,0,1,0,1],
#     # 4
#     [1,1,0,0,1,0,1],
#     # 5
#     [1,1,0,0,1,0,1],
#     # 6
#     [1,1,0,0,1,0,1]
# ]

vec_array = [

    # 0
    [0,1,1,0,0],
    # 1
    [1,0,1,0,0],
    # 2
    [1,1,0,1,0],
    # 3
    [0,0,1,0,1],
    # 4
    [0,0,0,1,0]
]

s = 2
d = 4

def finder(vec, s, d):
    traversed = set()
    current_breadth = set([s])
    next_breadth = set()
    print(type(next_breadth))

    steps = 0 
    while current_breadth != []:
        print(next_breadth, current_breadth)
        # a = input()
        break_flag = False

        for node in current_breadth:
            # node = 2
            print("iterating", node, vec[node])
            traversed.add(node)
            if node == d:
                return steps
            for idx, i in enumerate(vec[node]):
                if idx not in traversed and idx not in current_breadth and i == 1:
                    print("Added", idx)
                    next_breadth.add(idx)
                else:
                    print(f"idx: {idx} is already traversed")

            print("========>>", next_breadth)
            print(node, d)

            # Found the destination
            if node == d:
                print("steps ::", d)
                break_flag = True
                current_breadth = next_breadth  # next assignment
                next_breadth = set()  # flush
                break
        print("adding step after breadths: ", current_breadth, next_breadth, steps)
        current_breadth = next_breadth
        next_breadth = set()
        if break_flag:
            break
        steps += 1

if __name__ == "__main__":
    vec = vec_array
    aaa = finder(vec, s, d)
    print("ANS: ", aaa)


#ChatGPT

from collections import deque

def findConnectionLevel(n, Gmat, Px, Py):
    if Px == Py:
        return 0

    visited = [False] * n
    level = [0] * n

    queue = deque()
    queue.append(Px)
    visited[Px] = True

    while queue:
        person = queue.popleft()

        for neighbor in range(n):
            if Gmat[person][neighbor] == 1 and not visited[neighbor]:
                visited[neighbor] = True
                level[neighbor] = level[person] + 1

                if neighbor == Py:
                    return level[neighbor]

                queue.append(neighbor)

    return 0
vertices = int(input())
Amat = []
for i in range(vertices):
  row = [int(item) for item in input().split(" ")]
  Amat.append(row)
personX = int(input())
personY = int(input())
print(findConnectionLevel(vertices, Amat, personX, personY))